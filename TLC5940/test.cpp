#include <avr/io.h>
#include <util/delay.h>
#define TLC5940_SIN_BIT		0
#define TLC5940_SIN_PORT	PORTC
#define TLC5940_SIN_DDR		DDRC
#define TLC5940_SIN_PIN		PINC

#define TLC5940_XLAT_BIT	7
#define TLC5940_XLAT_PORT	PORTD
#define TLC5940_XLAT_DDR	DDRD
#define TLC5940_XLAT_PINS	PIND

#define TLC5940_SCLK_BIT	4
#define TLC5940_SCLK_PORT	PORTD
#define TLC5940_SCLK_DDR	DDRD
#define TLC5940_SCLK_PINS	PIND

#define TLC5940_DCPRG_BIT	4
#define TLC5940_DCPRG_PORT	PORTB
#define TLC5940_DCPRG_DDR	DDRB
#define TLC5940_DCPRG_PINS	PINB

#define TLC5940_VPRG_BIT	5
#define TLC5940_VPRG_PORT	PORTB
#define TLC5940_VPRG_DDR	DDRB
#define TLC5940_VPRG_PINS	PINB

#define nop()  __asm__ __volatile__("nop")

int main() {
	// Set output pins
	TLC5940_SIN_DDR |= 1<<TLC5940_SIN_BIT;
	TLC5940_XLAT_DDR |= 1<<TLC5940_XLAT_BIT;
	TLC5940_SCLK_DDR |= 1<<TLC5940_SCLK_BIT;
	TLC5940_DCPRG_DDR |= 1<<TLC5940_DCPRG_BIT;
	TLC5940_VPRG_DDR |= 1<<TLC5940_VPRG_BIT;
	
	// Greyscale timer
	//~ Setting the COM2x1:0 bits to two will produce a non-inverted PWM and an inverted PWM output
	//~ can be generated by setting the COM2x1:0 to three
	DDRB |= 1<<3;		// OC2A is PB3, we are using PWM to toggle BLANK using that pin
#ifndef XXX
	TCCR2A = 0
		|(1<<COM2A1)|(0<<COM2A0)	// Non-inverting mode
		|(1<<WGM21)|(1<<WGM20)		// Fast PWM
		;
	TCCR2B = 0
		|(0<<WGM22)							// Fast PWM
		|(0<<CS22)|(0<<CS21)|(1<<CS20)		// Prescaler = 1
		;
	OCR2A = 0x02;				/* 	If the OCR2A is set equal to BOTTOM, the output will
									be a narrow spike for each MAX+1 timer clock cycle. */
	//~ OCR2A = 0x80;
#endif	
	// VPRG -> low: start with pwm mode
	TLC5940_VPRG_PORT &= ~(1<<TLC5940_VPRG_BIT);
	// DCPRG -> low
	TLC5940_DCPRG_PORT &= ~(1<<TLC5940_DCPRG_BIT);
	
	//~ for (;;) {
	
	//~ static uint8_t nIntensityValueArray[3] = {0, 0, 0};
	static uint8_t idxColor;
	static uint8_t idxDir=1;
	static uint8_t anLEDColors[3] = {0, 0, 0};
	static uint8_t anLEDOutput[3] = {0xFF, 0x00, 0x00};
	
	
	while (1) {
		nop();
		TLC5940_XLAT_PORT &= ~(1<<TLC5940_XLAT_BIT);		// XLAT -> low
		
		for (uint8_t idxLED = 0; idxLED<5; idxLED++) {
			for (uint8_t idxLine=0;idxLine<3;idxLine++) {
				
				// Send zeros for high 4 bits
				for (uint8_t idxBit=0;idxBit<4;idxBit++) {
					TLC5940_SCLK_PORT 	&= ~(1<<TLC5940_SCLK_BIT);	// SCLK->low
					
					TLC5940_SIN_PORT 	&= ~(1<<TLC5940_SIN_BIT);	// SIN->low
					
					TLC5940_SCLK_PORT 	|= 1<<TLC5940_SCLK_BIT;		// SCLK->high 
				}
				
				// Send data for low 8 buts
				for (int idxBit=7;idxBit>=0;idxBit--) {
					TLC5940_SCLK_PORT 	&= ~(1<<TLC5940_SCLK_BIT);	// SCLK->low
					
					if (anLEDOutput[idxLine]&(1<<idxBit)) {
						TLC5940_SIN_PORT 	|= 1<<TLC5940_SIN_BIT;		// SIN->high 
					} else {
						TLC5940_SIN_PORT 	&= ~(1<<TLC5940_SIN_BIT);	// SIN->low 
					}
					TLC5940_SCLK_PORT 	|= 1<<TLC5940_SCLK_BIT;		// SCLK->high 
					//~ nop();
				}
			}
		}
		
		TLC5940_XLAT_PORT |= 1<<TLC5940_XLAT_BIT;			// XLAT -> high
		
		_delay_ms(5);
#ifndef XXX		
		if (
				((idxDir) && (anLEDColors[idxColor] >= 8))
			||
				((!idxDir) && (anLEDColors[idxColor] == 0x00))
			)
				if ( (idxDir = !idxDir) ) {
					if (idxColor++> 2) {
						idxColor = 0;
					}
				}
		if (idxDir) 
			anLEDColors[idxColor]++;
		else 
			anLEDColors[idxColor]--;
		
		for (int i=0;i<3;i++) {
			anLEDOutput[i] = ((uint16_t)1<<(uint16_t)anLEDColors[i])-(uint16_t)1;
		}
#endif		
	}
}